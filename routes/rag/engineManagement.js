const axios = require("axios");
const { auth, PROJECT_ID, LOCATION, dbPool } = require("./config");

class EngineManagement {
  constructor() {
    this.auth = auth;
    this.projectId = PROJECT_ID;
    this.location = LOCATION;
    this.db = dbPool;
    this.lastApiCall = 0;
    this.minApiInterval = 2000; // 2ÁßíÈñìÈöî
  }

  // Ê∑ªÂä†ÈÄüÁéáÈôêÂà∂ÊñπÊ≥ï
  async rateLimitedCall(apiCall) {
    const now = Date.now();
    const timeSinceLastCall = now - this.lastApiCall;

    if (timeSinceLastCall < this.minApiInterval) {
      const waitTime = this.minApiInterval - timeSinceLastCall;
      console.log(`Rate limiting: waiting ${waitTime}ms before API call`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }

    this.lastApiCall = Date.now();
    return await apiCall();
  }

  // üèóÔ∏è ÁÇ∫Áî®Êà∂ÂâµÂª∫Â∞àÂ±¨ÁöÑ RAG EngineÔºà‰øÆÊ≠£Áâà - Áµ±‰∏ÄÂëΩÂêç‰∏¶‰øùÂ≠òÂà∞Ë≥áÊñôÂ∫´Ôºâ
  async createUserRAGEngine(
    userId,
    engineName = null,
    description = null,
    visibility = "private"
  ) {
    try {
      console.log(`üèóÔ∏è === COMPLETE RAG ENGINE CREATION WITH ASYNC SUPPORT ===`);
      console.log(`üë§ User ID: ${userId}`);
      console.log(`üìõ Engine Name: ${engineName}`);

      // Step 1: Ë™çË≠â
      const authClient = await this.auth.getClient();
      const accessToken = await authClient.getAccessToken();
      console.log(`‚úÖ Authentication successful`);

      // Step 2: Ê∫ñÂÇôÊï∏Êìö
      const corpusId = `rag_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      const finalDisplayName = `${userId}_${engineName || "default"}`;
      const finalRagName = engineName || `${userId}_default_rag`;
      
      // ÂàùÂßãÂåñ corpusName ËÆäÊï∏
      let corpusName = null;

      console.log(`üÜî Generated Corpus ID: ${corpusId}`);
      console.log(`üìõ Display Name: ${finalDisplayName}`);

      const corpusData = {
        displayName: finalDisplayName,
        description:
          description ||
          `RAG corpus for user ${userId} - ${engineName} - Created ${new Date().toISOString()}`,
      };

      // Step 3: ÁôºÈÄÅÂâµÂª∫Ë´ãÊ±Ç
      const createUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/projects/${this.projectId}/locations/${this.location}/ragCorpora`;

      console.log(`üì§ Creating RAG Corpus...`);
      console.log(`üîó URL: ${createUrl}`);
      console.log(`üì¶ Data:`, JSON.stringify(corpusData, null, 2));

      const response = await axios.post(createUrl, corpusData, {
        headers: {
          Authorization: `Bearer ${accessToken.token}`,
          "Content-Type": "application/json",
        },
        timeout: 60000, // 60ÁßíË∂ÖÊôÇ
      });

      console.log(`üì® Creation Response Status: ${response.status}`);
      console.log(`üì® Response Data:`, JSON.stringify(response.data, null, 2));

      let finalCorpusId;

      // Step 4: Ê™¢Êü•ÊòØÂê¶ÁÇ∫Áï∞Ê≠•Êìç‰Ωú
      if (response.data.name && response.data.name.includes("/operations/")) {
        console.log(`‚è≥ Detected ASYNC operation: ${response.data.name}`);
        console.log(`‚è≥ Waiting for operation to complete...`);

        // Á≠âÂæÖÁï∞Ê≠•Êìç‰ΩúÂÆåÊàê
        const operationResult = await this.waitForOperation(
          response.data.name,
          300000
        ); // 5ÂàÜÈêòË∂ÖÊôÇ

        if (!operationResult.success) {
          throw new Error(
            `Async operation failed: ${JSON.stringify(operationResult.error)}`
          );
        }

        console.log(`‚úÖ Async operation completed successfully`);
        console.log(
          `‚úÖ Operation result:`,
          JSON.stringify(operationResult.result, null, 2)
        );

        corpusName = operationResult.result?.name;
        if (!corpusName) {
          throw new Error("No corpus name found in async operation result");
        }

        finalCorpusId = corpusName.split("/").pop();
        console.log(`‚úÖ Final Corpus Name from async: ${corpusName}`);
        console.log(`‚úÖ Final Corpus ID from async: ${finalCorpusId}`);
      } else {
        // ÂêåÊ≠•Êìç‰Ωú
        console.log(`‚úÖ Detected SYNC operation`);
        corpusName = response.data.name;
        finalCorpusId = corpusName.split("/").pop();
        console.log(`‚úÖ Final Corpus Name from sync: ${corpusName}`);
        console.log(`‚úÖ Final Corpus ID from sync: ${finalCorpusId}`);
      }

      // Step 5: Á´ãÂç≥È©óË≠âÂâµÂª∫ÁµêÊûú
      console.log(`üîç === IMMEDIATE VERIFICATION ===`);
      try {
        const verifyUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/${corpusName}`;
        console.log(`üîç Verification URL: ${verifyUrl}`);

        const verifyResponse = await axios.get(verifyUrl, {
          headers: {
            Authorization: `Bearer ${accessToken.token}`,
            "Content-Type": "application/json",
          },
          timeout: 30000,
        });

        console.log(`‚úÖ RAG Corpus verification successful!`);
        console.log(`‚úÖ Corpus State: ${verifyResponse.data.state}`);
        console.log(
          `‚úÖ Corpus Display Name: ${verifyResponse.data.displayName}`
        );

        // Ê™¢Êü•ÁãÄÊÖã
        if (
          verifyResponse.data.state &&
          verifyResponse.data.state !== "ACTIVE"
        ) {
          console.log(
            `‚ö†Ô∏è Corpus state is: ${verifyResponse.data.state} (not ACTIVE yet)`
          );
          console.log(`‚ö†Ô∏è This is normal for newly created corpus`);
        }
      } catch (verifyError) {
        console.error(`‚ùå Immediate verification failed:`, {
          status: verifyError.response?.status,
          data: verifyError.response?.data,
          message: verifyError.message,
        });

        // Â¶ÇÊûúÈ©óË≠âÂ§±ÊïóÔºåÁ≠âÂæÖ‰∏ÄÊÆµÊôÇÈñìÂæåÈáçË©¶
        console.log(`‚è≥ Waiting 30 seconds before retry verification...`);
        await new Promise((resolve) => setTimeout(resolve, 30000));

        try {
          const retryVerifyResponse = await axios.get(verifyUrl, {
            headers: {
              Authorization: `Bearer ${accessToken.token}`,
              "Content-Type": "application/json",
            },
            timeout: 30000,
          });

          console.log(`‚úÖ Retry verification successful!`);
          console.log(`‚úÖ Corpus State: ${retryVerifyResponse.data.state}`);
        } catch (retryError) {
          console.error(
            `‚ùå Retry verification also failed:`,
            retryError.response?.data
          );
          console.warn(
            `‚ö†Ô∏è Continuing with database save despite verification failure...`
          );
        }
      }

      // Step 6: ‰øùÂ≠òÂà∞Ë≥áÊñôÂ∫´
      console.log(`üíæ === DATABASE SAVE ===`);
      try {
        const insertQuery = `
          INSERT INTO rag (ragid, userid, ragname, visibility, created_at, updated_at) 
          VALUES (?, ?, ?, ?, NOW(), NOW())
        `;

        console.log(
          `üíæ Saving to database: [${finalCorpusId}, ${userId}, ${finalRagName}, ${visibility}]`
        );

        await this.db.execute(insertQuery, [
          finalCorpusId,
          userId,
          finalRagName,
          visibility,
        ]);

        console.log(`‚úÖ Successfully saved to database: ${finalCorpusId}`);
      } catch (dbError) {
        console.error("‚ùå Database save failed:", dbError);
        throw dbError;
      }

      return {
        success: true,
        userId: userId,
        engineId: finalCorpusId,
        corpusId: finalCorpusId,
        corpusName: corpusName,
        displayName: finalDisplayName,
        ragName: finalRagName,
        visibility: visibility,
        bucketPath: `user-data/${userId}`,
        createdAt: new Date().toISOString(),
        message: `RAG Engine "${finalRagName}" created successfully and ready for use`,
        engine: {
          ragid: finalCorpusId,
          ragname: finalRagName,
          visibility: visibility,
          created_at: new Date().toISOString(),
        },
        // Ê∑ªÂä†ÁãÄÊÖã‰ø°ÊÅØ
        isAsyncOperation:
          response.data.name && response.data.name.includes("/operations/"),
        readyForUse: true,
      };
    } catch (error) {
      console.error(`‚ùå === RAG ENGINE CREATION FAILED ===`);
      console.error(`‚ùå Error Details:`);
      console.error(`   - Type: ${error.constructor.name}`);
      console.error(`   - Message: ${error.message}`);
      console.error(`   - Status: ${error.response?.status}`);
      console.error(
        `   - Data: ${JSON.stringify(error.response?.data, null, 2)}`
      );
      console.error(`   - Stack: ${error.stack}`);

      return {
        success: false,
        error: error.message,
        details: error.response?.data,
        statusCode: error.response?.status,
        message: "Failed to create RAG Engine",
      };
    }
  }

  async waitForOperation(operationName, maxWaitTime = 300000) {
    try {
      const authClient = await this.auth.getClient();
      const startTime = Date.now();
      let attemptCount = 0;

      console.log(`‚è≥ === WAITING FOR ASYNC OPERATION ===`);
      console.log(`üìõ Operation: ${operationName}`);
      console.log(`‚è∞ Max wait time: ${maxWaitTime / 1000} seconds`);

      while (Date.now() - startTime < maxWaitTime) {
        attemptCount++;
        console.log(`üîÑ Attempt ${attemptCount}: Checking operation status...`);

        const accessToken = await authClient.getAccessToken();
        const statusUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/${operationName}`;

        try {
          const response = await axios.get(statusUrl, {
            headers: {
              Authorization: `Bearer ${accessToken.token}`,
              "Content-Type": "application/json",
            },
            timeout: 30000,
          });

          const operation = response.data;
          console.log(
            `üìä Operation status: done=${operation.done}, name=${operation.name}`
          );

          if (operation.done) {
            if (operation.error) {
              console.error(
                `‚ùå Operation completed with error:`,
                operation.error
              );
              return {
                success: false,
                error: operation.error,
              };
            }

            console.log(`‚úÖ Operation completed successfully!`);
            console.log(
              `‚úÖ Result:`,
              JSON.stringify(operation.response, null, 2)
            );

            return {
              success: true,
              result: operation.response,
              metadata: operation.metadata,
              attemptCount: attemptCount,
              totalWaitTime: Date.now() - startTime,
            };
          }

          // È°ØÁ§∫ÈÄ≤Â∫¶
          const elapsedTime = Math.round((Date.now() - startTime) / 1000);
          console.log(`‚è≥ Still waiting... (${elapsedTime}s elapsed)`);

          // Á≠âÂæÖ 15 ÁßíÂæåÈáçË©¶
          await new Promise((resolve) => setTimeout(resolve, 15000));
        } catch (statusError) {
          console.error(
            `‚ùå Failed to check operation status (attempt ${attemptCount}):`,
            statusError.response?.data || statusError.message
          );

          // Â¶ÇÊûúÊòØÁ∂≤Áµ°ÈåØË™§ÔºåÁ≠âÂæÖÂæåÈáçË©¶
          if (
            statusError.code === "ECONNRESET" ||
            statusError.code === "ETIMEDOUT"
          ) {
            console.log(`üîÑ Network error, retrying in 10 seconds...`);
            await new Promise((resolve) => setTimeout(resolve, 10000));
            continue;
          }

          // ÂÖ∂‰ªñÈåØË™§ÔºåÁ≠âÂæÖÂæåÈáçË©¶
          await new Promise((resolve) => setTimeout(resolve, 10000));
        }
      }

      console.error(`‚ùå Operation timeout after ${maxWaitTime / 1000} seconds`);
      return {
        success: false,
        error: "Operation timeout",
        attemptCount: attemptCount,
        totalWaitTime: maxWaitTime,
      };
    } catch (error) {
      console.error("‚ùå Error waiting for operation:", error.message);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // üìã ÂàóÂá∫ÊâÄÊúâ RAG Engines - Êï¥ÂêàË≥áÊñôÂ∫´‰ø°ÊÅØÔºàÊîØÊè¥ÂàÜÈ†ÅÔºâ
  async listAllRAGEngines(pageSize = 100) {
    try {
      return await this.rateLimitedCall(async () => {
        const authClient = await this.auth.getClient();
        const accessToken = await authClient.getAccessToken();

        let allRagCorpora = [];
        let nextPageToken = null;
        let totalPages = 0;

        do {
          const listUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/projects/${this.projectId}/locations/${this.location}/ragCorpora`;

          // ÊßãÂª∫Êü•Ë©¢ÂèÉÊï∏
          const params = new URLSearchParams();
          params.append("pageSize", pageSize.toString());
          if (nextPageToken) {
            params.append("pageToken", nextPageToken);
          }

          const fullUrl = `${listUrl}?${params.toString()}`;
          console.log(
            `Listing RAG engines from: ${fullUrl} (Page ${totalPages + 1})`
          );

          const response = await axios.get(fullUrl, {
            headers: {
              Authorization: `Bearer ${accessToken.token}`,
              "Content-Type": "application/json",
            },
          });

          const ragCorpora = response.data.ragCorpora || [];
          allRagCorpora = allRagCorpora.concat(ragCorpora);

          nextPageToken = response.data.nextPageToken;
          totalPages++;

          console.log(
            `Page ${totalPages}: Found ${ragCorpora.length} RAG corpora (Total so far: ${allRagCorpora.length})`
          );

          // ÂÆâÂÖ®Ê™¢Êü•ÔºöÈò≤Ê≠¢ÁÑ°ÈôêÂæ™Áí∞
          if (totalPages > 10) {
            console.warn(`ÂÅúÊ≠¢ÂàÜÈ†ÅË´ãÊ±ÇÔºåÂ∑≤ËôïÁêÜ ${totalPages} È†Å`);
            break;
          }
        } while (nextPageToken);

        console.log(
          `‚úÖ ÂàÜÈ†ÅÂÆåÊàêÔºöÂÖ± ${totalPages} È†ÅÔºåÁ∏ΩË®à ${allRagCorpora.length} ÂÄã RAG Engines`
        );

        // ÂæûË≥áÊñôÂ∫´Áç≤ÂèñÈ°çÂ§ñ‰ø°ÊÅØ
        const [dbRags] = await this.db.execute("SELECT * FROM rag");
        const dbRagMap = {};
        dbRags.forEach((rag) => {
          dbRagMap[rag.ragid] = rag;
        });

        const engines = allRagCorpora.map((corpus) => {
          const corpusId = corpus.name
            ? corpus.name.split("/").pop()
            : "unknown";
          const dbInfo = dbRagMap[corpusId];

          const userId = this.extractUserIdFromEngine(corpus);

          return {
            id: corpusId,
            name: corpus.name || "Unknown",
            displayName: corpus.displayName || "Unknown",
            description: corpus.description || "",
            createTime: corpus.createTime || "Unknown",
            updateTime: corpus.updateTime || "Unknown",
            userId: userId,
            // Ë≥áÊñôÂ∫´‰ø°ÊÅØ
            ragName: dbInfo?.ragname || corpus.displayName,
            visibility: dbInfo?.visibility || "unknown",
            dbCreatedAt: dbInfo?.created_at,
            dbUpdatedAt: dbInfo?.updated_at,
            hasDbRecord: !!dbInfo,
          };
        });

        return {
          success: true,
          engines: engines,
          totalEngines: engines.length,
          dbEngines: dbRags.length,
          totalPages: totalPages,
          timestamp: new Date().toISOString(),
          pagination: {
            requestedPageSize: pageSize,
            actualPages: totalPages,
            totalResults: engines.length,
            hasMultiplePages: totalPages > 1,
          },
        };
      });
    } catch (error) {
      console.error(
        "List RAG engines error:",
        error.response?.data || error.message
      );

      if (error.response?.data?.error?.code === 429) {
        return {
          success: false,
          error: "Rate limit exceeded",
          userMessage: "Ë´ãÊ±ÇÈÅéÊñºÈ†ªÁπÅÔºåË´ãÁ®çÂæåÂÜçË©¶",
          retryAfter: 60,
        };
      }

      return {
        success: false,
        error: error.response?.data || error.message,
      };
    }
  }

  // üîç Âæû Engine ‰∏≠ÊèêÂèñÁî®Êà∂ IDÔºàÊîπËøõÁâà - ÊîØÊåÅÊï∏ÊìöÂ∫´ UUID ÂíåËàäÊ†ºÂºèÁî®Êà∂ÂêçÔºâ
  extractUserIdFromEngine(corpus) {
    // ÂòóË©¶Âæû displayName ‰∏≠ÊèêÂèñÔºàÊñ∞Ê†ºÂºèÔºöuserId - engineNameÔºâ
    if (corpus.displayName) {
      // ÂåπÈÖçÊñ∞Ê†ºÂºè "userId - engineName"
      const newFormatMatch = corpus.displayName.match(
        /^([a-f0-9\-]{36}) - (.+)$/
      );
      if (newFormatMatch) {
        return newFormatMatch[1];
      }

      // ÂåπÈÖçËàäÊ†ºÂºè "userId-engineName"
      const oldFormatMatch = corpus.displayName.match(
        /^([a-f0-9\-]{36})-(.+)$/
      );
      if (oldFormatMatch) {
        return oldFormatMatch[1];
      }

      // ÂåπÈÖç Knowledge Base Ê†ºÂºè "userId Knowledge Base"
      const kbFormatMatch = corpus.displayName.match(
        /^([a-f0-9\-]{36}) Knowledge Base$/
      );
      if (kbFormatMatch) {
        return kbFormatMatch[1];
      }

      // üÜï ÂåπÈÖçËàäÁöÑÁî®Êà∂ÂêçÊ†ºÂºè "username's Knowledge Base"
      const legacyKbFormatMatch = corpus.displayName.match(
        /^(.+)'s Knowledge Base$/
      );
      if (legacyKbFormatMatch) {
        return `legacy_user_${legacyKbFormatMatch[1]}`;
      }

      // üÜï ÂåπÈÖçÂÖ∂‰ªñËàäÊ†ºÂºè "username-engineName"
      const legacyFormatMatch = corpus.displayName.match(/^([^-]+)-(.+)$/);
      if (
        legacyFormatMatch &&
        !legacyFormatMatch[1].match(/^[a-f0-9\-]{36}$/)
      ) {
        return `legacy_user_${legacyFormatMatch[1]}`;
      }
    }

    // ÂòóË©¶Âæû description ‰∏≠ÊèêÂèñÁî®Êà∂ IDÔºàUUIDÊ†ºÂºèÔºâ
    if (corpus.description) {
      const uuidMatch = corpus.description.match(/user ([a-f0-9\-]{36})/i);
      if (uuidMatch) {
        return uuidMatch[1];
      }

      // üÜï ÂòóË©¶Âæû description ‰∏≠ÊèêÂèñËàäÊ†ºÂºèÁî®Êà∂Âêç
      const legacyUserMatch = corpus.description.match(/user ([^-\s]+)/i);
      if (legacyUserMatch) {
        return `legacy_user_${legacyUserMatch[1]}`;
      }
    }

    return null;
  }

  // üîç Áç≤Âèñ Engine Êñá‰ª∂Êï∏Èáè
  async getEngineFileCount(corpusName) {
    try {
      const authClient = await this.auth.getClient();
      const accessToken = await authClient.getAccessToken();

      const filesUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/${corpusName}/ragFiles`;

      const response = await axios.get(filesUrl, {
        headers: {
          Authorization: `Bearer ${accessToken.token}`,
          "Content-Type": "application/json",
        },
      });

      const files = response.data.ragFiles || [];

      return {
        fileCount: files.length,
        status: files.length > 0 ? "active" : "empty",
        recentFiles: files.slice(-3),
      };
    } catch (error) {
      console.error(
        `Error getting file count for ${corpusName}:`,
        error.message
      );
      return {
        fileCount: 0,
        status: "unknown",
        recentFiles: [],
      };
    }
  }

  // üóëÔ∏è Âà™Èô§Êï¥ÂÄã RAG EngineÔºà‰øÆÊ≠£Áâà - ÂêåÊ≠•Âà™Èô§Ë≥áÊñôÂ∫´Ë®òÈåÑÔºâ
  async deleteUserRAGEngine(corpusName, userId) {
    try {
      const ragId = corpusName.split("/").pop();

      // Ê™¢Êü•Áî®Êà∂Ê¨äÈôê
      const checkQuery = "SELECT * FROM rag WHERE ragid = ? AND userid = ?";
      const [ragResults] = await this.db.execute(checkQuery, [ragId, userId]);

      if (ragResults.length === 0) {
        return {
          success: false,
          error: "ÊÇ®Ê≤íÊúâÊ¨äÈôêÂà™Èô§Ê≠§ RAG Engine",
        };
      }

      console.log(`üóëÔ∏è Deleting RAG Engine: ${corpusName}`);

      const authClient = await this.auth.getClient();
      const accessToken = await authClient.getAccessToken();

      const deleteUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/${corpusName}`;

      const response = await axios.delete(deleteUrl, {
        headers: {
          Authorization: `Bearer ${accessToken.token}`,
          "Content-Type": "application/json",
        },
      });

      console.log("RAG Engine deletion response:", response.status);

      // ÂêåÊ≠•Âà™Èô§Ë≥áÊñôÂ∫´Ë®òÈåÑ
      try {
        await this.db.execute("DELETE FROM rag WHERE ragid = ?", [ragId]);
        console.log("‚úÖ RAG Engine removed from database");
      } catch (dbError) {
        console.error("‚ùå Failed to remove RAG Engine from database:", dbError);
        // ‰∏çÊããÂá∫ÈåØË™§ÔºåÂõ†ÁÇ∫ Google Cloud ‰∏≠ÁöÑ RAG Engine Â∑≤Ë¢´Âà™Èô§
      }

      return {
        success: true,
        message: "RAG Engine Â∑≤ÊàêÂäüÂà™Èô§",
        deletedEngine: corpusName,
      };
    } catch (error) {
      console.error(`‚ùå Failed to delete RAG Engine ${corpusName}:`);
      console.error("Error details:", {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status,
      });

      return {
        success: false,
        error: error.response?.data || error.message,
      };
    }
  }

  // üîß Ë®∫Êñ∑ Google Cloud Ë®≠ÁΩÆ
  async diagnoseGoogleCloudSetup() {
    try {
      console.log(`üîç === GOOGLE CLOUD SETUP DIAGNOSIS ===`);

      // Ê™¢Êü•Ë™çË≠â
      const authClient = await this.auth.getClient();
      const accessToken = await authClient.getAccessToken();
      console.log(`‚úÖ Authentication: OK`);
      console.log(
        `üîë Token length: ${accessToken.token ? accessToken.token.length : 0}`
      );

      // Ê™¢Êü•È†ÖÁõÆË®™ÂïèÊ¨äÈôê
      const testUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/projects/${this.projectId}/locations/${this.location}`;
      console.log(`üîç Testing project access: ${testUrl}`);

      const testResponse = await axios.get(testUrl, {
        headers: {
          Authorization: `Bearer ${accessToken.token}`,
          "Content-Type": "application/json",
        },
        timeout: 30000,
      });

      console.log(`‚úÖ Project access: OK`);
      console.log(`üìä Location info:`, testResponse.data);

      // ÂàóÂá∫ÁèæÊúâÁöÑ RAG Corpora
      const listUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/projects/${this.projectId}/locations/${this.location}/ragCorpora`;
      console.log(`üîç Listing existing RAG Corpora: ${listUrl}`);

      const listResponse = await axios.get(listUrl, {
        headers: {
          Authorization: `Bearer ${accessToken.token}`,
          "Content-Type": "application/json",
        },
        timeout: 30000,
      });

      console.log(`‚úÖ RAG Corpora list: OK`);
      console.log(
        `üìä Existing corpora count:`,
        listResponse.data.ragCorpora?.length || 0
      );

      return {
        success: true,
        authentication: "OK",
        projectAccess: "OK",
        existingCorpora: listResponse.data.ragCorpora || [],
        corporaCount: listResponse.data.ragCorpora?.length || 0,
        projectId: this.projectId,
        location: this.location,
        message: "Google Cloud setup is working correctly",
      };
    } catch (error) {
      console.error(
        `‚ùå Google Cloud diagnosis failed:`,
        error.response?.data || error.message
      );
      return {
        success: false,
        error: error.response?.data || error.message,
        errorStatus: error.response?.status,
        projectId: this.projectId,
        location: this.location,
        message: "Google Cloud setup has issues",
      };
    }
  }

  // üîß Á∞°ÂåñÁöÑ RAG Corpus ÂâµÂª∫ÊñπÊ≥ï - Áî®ÊñºË™øË©¶
  async createSimpleRAGCorpus(userId, engineName = "test") {
    try {
      console.log(`üèóÔ∏è === SIMPLE RAG CORPUS CREATION FOR DEBUG ===`);
      console.log(`üë§ User ID: ${userId}`);
      console.log(`üìõ Engine Name: ${engineName}`);

      // Step 1: Ë™çË≠â
      const authClient = await this.auth.getClient();
      const accessToken = await authClient.getAccessToken();
      console.log(`‚úÖ Authentication successful`);

      // Step 2: Ê∫ñÂÇôÊúÄÁ∞°ÂñÆÁöÑÊï∏Êìö
      const corpusData = {
        displayName: `debug_${userId}_${Date.now()}`,
        description: `Debug RAG corpus for ${userId} created at ${new Date().toISOString()}`,
      };

      // Step 3: ÁôºÈÄÅÂâµÂª∫Ë´ãÊ±Ç
      const createUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/projects/${this.projectId}/locations/${this.location}/ragCorpora`;

      console.log(`üì§ Creating Simple RAG Corpus...`);
      console.log(`üîó URL: ${createUrl}`);
      console.log(`üì¶ Data:`, JSON.stringify(corpusData, null, 2));

      const response = await axios.post(createUrl, corpusData, {
        headers: {
          Authorization: `Bearer ${accessToken.token}`,
          "Content-Type": "application/json",
        },
        timeout: 60000,
      });

      console.log(`üì® Creation Response Status: ${response.status}`);
      console.log(`üì® Response Data:`, JSON.stringify(response.data, null, 2));

      let corpusName, corpusId;

      // üîß ‰øÆÂæ©ÔºöÊ™¢Êü•ÊòØÂê¶ÊòØÁï∞Ê≠•Êìç‰Ωú
      if (response.data.name && response.data.name.includes('/operations/')) {
        console.log(`‚è≥ Detected ASYNC operation: ${response.data.name}`);
        
        // Á≠âÂæÖÁï∞Ê≠•Êìç‰ΩúÂÆåÊàê
        const operationResult = await this.waitForOperation(response.data.name, 120000); // 2ÂàÜÈêòË∂ÖÊôÇ
        
        if (!operationResult.success) {
          throw new Error(`Async operation failed: ${JSON.stringify(operationResult.error)}`);
        }
        
        console.log(`‚úÖ Async operation completed successfully`);
        
        // Âæû operation result ‰∏≠Áç≤ÂèñÁúüÊ≠£ÁöÑ corpus ‰ø°ÊÅØ
        if (operationResult.result && operationResult.result.name) {
          corpusName = operationResult.result.name;
          corpusId = corpusName.split('/').pop();
          console.log(`‚úÖ Corpus created via async: ${corpusName}`);
        } else {
          throw new Error('No corpus name found in async operation result');
        }
      } else {
        // ÂêåÊ≠•Êìç‰Ωú
        corpusName = response.data.name;
        corpusId = corpusName.split("/").pop();
        console.log(`‚úÖ Corpus created synchronously: ${corpusName}`);
      }

      // Á´ãÂç≥È©óË≠â
      const verifyUrl = `https://${this.location}-aiplatform.googleapis.com/v1beta1/${corpusName}`;
      console.log(`üîç Verifying corpus: ${verifyUrl}`);

      const verifyResponse = await axios.get(verifyUrl, {
        headers: {
          Authorization: `Bearer ${accessToken.token}`,
          "Content-Type": "application/json",
        },
        timeout: 30000,
      });

      console.log(`‚úÖ Verification successful!`);
      console.log(`‚úÖ Corpus State: ${verifyResponse.data.state}`);

      return {
        success: true,
        corpusId: corpusId,
        corpusName: corpusName,
        displayName: corpusData.displayName,
        state: verifyResponse.data.state,
        message: "Simple RAG Corpus created successfully",
      };
    } catch (error) {
      console.error(`‚ùå Simple RAG creation failed:`, {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });

      return {
        success: false,
        error: error.message,
        details: error.response?.data,
        statusCode: error.response?.status,
      };
    }
  }
  async shareRAGEngineToUser(ownerId, ragId, targetUsername) {
    try {
      // Ê™¢Êü• owner ÊòØÂê¶ÁúüÁöÑÊìÅÊúâÈÄôÂÄã engine
      const [rows] = await this.db.execute(
        "SELECT * FROM rag WHERE ragid = ? AND userid = ?",
        [ragId, ownerId]
      );
      if (rows.length === 0) {
        return { success: false, error: "ÊÇ®Ê≤íÊúâÊ¨äÈôêÂàÜ‰∫´Ê≠§ RAG Engine" };
      }

      // Ê†πÊìö username Êü•ÊâæÁõÆÊ®ôÁî®Êà∂ÁöÑ userid
      const [userRows] = await this.db.execute(
        "SELECT userid FROM users WHERE username = ?",
        [targetUsername]
      );
      if (userRows.length === 0) {
        return { success: false, error: "Êâæ‰∏çÂà∞ÊåáÂÆöÁöÑÁî®Êà∂Âêç" };
      }
      const targetUserId = userRows[0].userid;

      // Ê™¢Êü•ÊòØÂê¶ÊòØÂ•ΩÂèãÈóú‰øÇ (ÊîØÊè¥ known Âíå Known Â≠óÊÆµ)
      const [friendshipRows1] = await this.db.execute(
        "SELECT * FROM friendship WHERE (userid = ? AND friendid = ? AND known = 'true') OR (userid = ? AND friendid = ? AND known = 'true')",
        [ownerId, targetUserId, targetUserId, ownerId]
      );
      
      const [friendshipRows2] = await this.db.execute(
        "SELECT * FROM friendship WHERE (userid = ? AND friendid = ? AND Known = 'true') OR (userid = ? AND friendid = ? AND Known = 'true')",
        [ownerId, targetUserId, targetUserId, ownerId]
      );

      if (friendshipRows1.length === 0 && friendshipRows2.length === 0) {
        return { success: false, error: "Âè™ËÉΩÂàÜ‰∫´Áµ¶ÊÇ®ÁöÑÂ•ΩÂèã" };
      }

      // Ê™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÂàÜ‰∫´ÈÅé
      const [existing] = await this.db.execute(
        "SELECT * FROM private_rag WHERE ragid = ? AND userid = ?",
        [ragId, targetUserId]
      );
      if (existing.length > 0) {
        return { success: false, error: "Â∑≤Á∂ìÂàÜ‰∫´Áµ¶Ê≠§Áî®Êà∂" };
      }

      // Âü∑Ë°åÂàÜ‰∫´
      await this.db.execute(
        "INSERT INTO private_rag (ragid, userid) VALUES (?, ?)",
        [ragId, targetUserId]
      );
      
      return { 
        success: true, 
        message: `RAG Engine Â∑≤ÊàêÂäüÂàÜ‰∫´Áµ¶ ${targetUsername}`,
        targetUsername: targetUsername,
        targetUserId: targetUserId
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

}

module.exports = EngineManagement;
